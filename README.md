## How to run

1. Clone the repo.
2. Open the repo's folder in a command window. Run `npm install`.
3. Run `node server.js` to start the web server.

## How to build

Most of these steps you'll only ever have to do once, but this just makes sure you have the right settings. Once you know your settings are right, you can just Build in Unity and push to Github.

1. Clone this repository and the KeyWave repository.
2. Open the KeyWave Unity project.
3. Go to the Build Settings and change the target platform to WebGL.
3a. Set Code Optimization to Size and IL2CPP Code Gen to Faster (smaller) builds.
4. Go to the Project settings, then select Player, then the HTML5 tab.
4a. Ensure the selected WebGL template is "Perils&Pitfalls"
4b. Disable "Strip Engine Code" and set Managed Stripping Level to Low.
4c. Set Enable Exceptions to Explicitly Thrown only
4d. Set Debug Symbols to Embedded and Compression to Disabled IF this is a development build. If it's a full deployment, disable symbols and use Gzip compression.
5. Back in the Build Settings, click Build. Select the output folder to be the PerilsAndPitfallsWebView folder (this repository).
6. Commit and push changes to Github. On Github you will see a green checkmark next to the commit once it is published. You can also verify this by opening the game page and seeing if the Build date updates to the current date. 

## Things of note
The `game/` directory holds all client files. `Build/`, `StreamingAssets/`, and `index.html` are the output of the Unity build and may be overwritten.

- `index.html` sets up a canvas for the Unity game and loads necessary scripts.
- `socket.js` maintains the websocket connection and listens/emits events to and from the Unity game
- `unityInstance.js` does some setup for the Unity game, instructing the browser on decompression and providing a global instance variable

`server.js` is a basic Express server for in-development testing. Note that some Content-Encoding headers need to be provided for certain files or else the client browser will complain.

## How Unity communicates with the browser
Information flows from Unity to the browser in this order (and vice versa):

1. The Unity Game's WebAssembly wants to run a Javascript function, and triggers an external library call
2. The `game.framework.js` is generated by Unity and interfaces between the WebAssembly (game) and the browser. A function is called here that emits an event within the DOM.
3. The code in `socket.js` listens for those DOM events and emits a socket event.
4. If there is data that needs to be passed back to Unity, it goes back through the `game.framework.js` and into a WebAssembly function call.
